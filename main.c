/**
 * compiler.c â€“ Driver program for the mini-c compiler
 * 
 * Rohan Kartha, April 2024
 * 
*/








/**************** dependencies ****************/
#include "front-end/ast/ast.h"
#include "front-end/y.tab.h"
#include <stdlib.h>
#include <stdio.h>
#include <cstddef>
#include <vector>
#include "front-end/semantic-analysis.h"
#include <stdbool.h>
#include <llvm-c/Core.h>
#include <llvm-c/IRReader.h>
#include <llvm-c/Types.h>
#include "optimizations/optimizations.h"
#include "optimizations/optimizer.h"
#include <unordered_map>
#include <set>
#include <string.h>
#include "irbuilder/irbuilder.h"
#include "assembly-code-gen/assemblycodegen.h"
extern FILE* yyin;
extern int yylex_destroy();
using namespace std;
#define prt(x) if(x) { printf("%s\n", x); }


/**************** global variables ****************/
//ast_Node* root = NULL;


void printInstIndex(unordered_map<LLVMValueRef, int>* instIndex);
void printLiveRange(unordered_map<LLVMValueRef, array<int, 2>>* liveRange);


/**************** main ****************/
int main(int argc, char* argv[]) 
{
    LLVMModuleRef m;
    char* filename;
    char* fileName;

    /* Section 1: Front-end */

    // Open mini-c file
    if (argc == 3) {
        yyin = fopen(argv[1], "r");


        fileName = argv[1];
        filename = argv[2];
        m = createLLVMModel(filename);

        if (yyin == NULL || m == NULL) {
            fprintf(stderr, "File open error");
            return 1;
        }
    }

    // Conduct lexical and syntax analysis of mini-c file
    yyparse();
    if (argc == 2) {
        fclose(yyin);
    }
    yylex_destroy();

    // Print abstract syntax tree (AST) generated by syntax analysis
    //printNode(root);
    

    // Conduct semantic analysis
    bool result = semanticAnalysis();

    if (result) {
        printf("Semantic analysis passed\n");
    }
    else {
        printf("Semantic analysis NOT passed\n");
    }

    // Free memory holding AST
    //freeNode(root);



    /* Section 2: IR builder */
    //unordered_map<string, LLVMValueRef> varLocs = renameVariables();
    readAstTree(fileName);
    //printNode(root);
    printf("END\n");
    fflush(stdout);

    


    





    /* Section 3: Optimizations */
    // LLVMPrintModuleToFile (m, "test_old.ll", NULL);
	// walkFunctions(m);
	// LLVMPrintModuleToFile (m, "test_new.ll", NULL);

	//LLVMDisposeModule(m);
	//LLVMShutdown();




    /* Section 4: Assembly code generation */

    LLVMModuleRef m2 = createLLVMModel("optimizations/optimizer_test_results/p4_const_prop_opt.ll");

    LLVMValueRef function =  LLVMGetFirstFunction(m2); 

	// for (LLVMBasicBlockRef basicBlock = LLVMGetFirstBasicBlock(function);
 	// 		basicBlock;
  	// 		basicBlock = LLVMGetNextBasicBlock(basicBlock)) {
        



    //     unordered_map<LLVMValueRef, int>* instIndex = new unordered_map<LLVMValueRef, int>;
    //     unordered_map<LLVMValueRef, array<int, 2>>* liveRange = new unordered_map<LLVMValueRef, array<int, 2>>;

        
    //     computeLiveness(basicBlock, instIndex, liveRange);

    //     printInstIndex(instIndex);

    //     printLiveRange(liveRange);

        

    // }

    // unordered_map<LLVMValueRef, string> registerAssignments = allocateRegisters(function);

    // int asd = registerAssignments.size();
    // printf("size: %d\n", asd);

    // for (auto iter = registerAssignments.begin(); iter != registerAssignments.end(); ++iter) {

    //     printf("ASDF\n");
    //     fflush(stdout);

    //     LLVMValueRef inst = iter->first;
    //     string regName = iter->second;

    //     printf("%s %s\n", LLVMPrintValueToString(inst), regName.c_str());
    //     fflush(stdout);
    // }


    return 0;
}
