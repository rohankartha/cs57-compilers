/**
 * compiler.c â€“ Driver program for the mini-c compiler
 * 
 * Rohan Kartha, April 2024
 * 
*/








/**************** dependencies ****************/
#include "front-end/ast/ast.h"
#include "front-end/y.tab.h"
#include <stdlib.h>
#include <stdio.h>
#include <cstddef>
#include <vector>
#include "front-end/semantic-analysis.h"
#include <stdbool.h>
#include <llvm-c/Core.h>
#include <llvm-c/IRReader.h>
#include <llvm-c/Types.h>
#include "optimizations/optimizations.h"
#include "optimizations/optimizer.h"
#include <unordered_map>
#include <set>
#include <string.h>
#include "irbuilder/irbuilder.h"
#include "assembly-code-gen/assemblycodegen.h"
extern FILE* yyin;
extern int yylex_destroy();
using namespace std;
#define prt(x) if(x) { printf("%s\n", x); }


/**************** global variables ****************/
//ast_Node* root = NULL;


void printInstIndex(unordered_map<LLVMValueRef, int>* instIndex);
void printLiveRange(unordered_map<LLVMValueRef, array<int, 2>>* liveRange);


/**************** main ****************/
int main(int argc, char* argv[]) 
{
    LLVMModuleRef m;
    char* filename;
    char* fileName;

    /* Section 1: Front-end */

    // Open mini-c file
    if (argc == 3) {
        yyin = fopen(argv[1], "r");


        fileName = argv[1];
        filename = argv[2];
        m = createLLVMModel(filename);

        if (yyin == NULL || m == NULL) {
            fprintf(stderr, "File open error");
            return 1;
        }
    }

    // Conduct lexical and syntax analysis of mini-c file
    yyparse();
    if (argc == 2) {
        fclose(yyin);
    }
    yylex_destroy();

    // Print abstract syntax tree (AST) generated by syntax analysis
    //printNode(root);
    

    // Conduct semantic analysis
    bool result = semanticAnalysis();

    if (result) {
        printf("Semantic analysis passed\n");
    }
    else {
        printf("Semantic analysis NOT passed\n");
    }

    // Free memory holding AST
    //freeNode(root);



    /* Section 2: IR builder */
    //unordered_map<string, LLVMValueRef> varLocs = renameVariables();
    //readAstTree(fileName);
    //printNode(root);

    


    





    /* Section 3: Optimizations */
    // LLVMPrintModuleToFile (m, "test_old.ll", NULL);
	// walkFunctions(m);
	// LLVMPrintModuleToFile (m, "test_new.ll", NULL);

	// LLVMDisposeModule(m);
	// LLVMShutdown();




    /* Section 4: Assembly code generation */

    LLVMModuleRef m2 = createLLVMModel("optimizations/optimizer_test_results/p4_const_prop_opt.ll");

    LLVMValueRef function =  LLVMGetFirstFunction(m2); 

	for (LLVMBasicBlockRef basicBlock = LLVMGetFirstBasicBlock(function);
 			basicBlock;
  			basicBlock = LLVMGetNextBasicBlock(basicBlock)) {
        



        unordered_map<LLVMValueRef, int>* instIndex = new unordered_map<LLVMValueRef, int>;
        unordered_map<LLVMValueRef, array<int, 2>>* liveRange = new unordered_map<LLVMValueRef, array<int, 2>>;

        
        computeLiveness(basicBlock, instIndex, liveRange);

        printInstIndex(instIndex);

        printLiveRange(liveRange);

        

    }

    





    return 0;
}





void printInstIndex(unordered_map<LLVMValueRef, int>* instIndex) {

    for (auto iter = instIndex->begin(); iter != instIndex->end(); ++iter) {

        LLVMValueRef inst = iter->first;
        

        int begIndex = iter->second;
        printf("Inst: %s    beg index: %d\n", LLVMPrintValueToString(inst), begIndex);
        fflush(stdout);
    }

    printf("\n\n");
}



void printLiveRange(unordered_map<LLVMValueRef, array<int, 2>>* liveRange) {

    for (auto iter = liveRange->begin(); iter != liveRange->end(); ++iter) {

        LLVMValueRef inst = iter->first;

        printf("Inst: %s    beg index: %d   end index: %d\n", LLVMPrintValueToString(inst), iter->second[0], iter->second[1]);
        fflush(stdout);

        
    }
    printf("\n\n");

}
